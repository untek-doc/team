# Примеры выражений

## Проверка надежности пароля

    ^(?=.*[A-Z].*[A-Z])(?=.*[!@#$&*])(?=.*[0-9].*[0-9])(?=.*[a-z].*[a-z].*[a-z]).{8}$

Надежность пароля - довольно субъективное понятие, поэтому не существует универсального решения 
для проверки. Однако, приведенный выше пример регулярного выражения может стать хорошей отправной точкой, 
если вы не желаете придумывать выражение для проверки пароля с нуля.

Строчные и прописные латинские буквы, цифры, спецсимволы. Минимум 8 символов

    (?=^.{8,}$)((?=.*\d)|(?=.*\W+))(?![.\n])(?=.*[A-Z])(?=.*[a-z]).*$

## Код цвета в шестнадцатеричном формате

    \#([a-fA-F]|[0-9]){3, 6}

Шестнадцатеричные коды цветов используются при веб-разработке очень часто. 
Это регулярное выражение может быть поможет сравнить: совпадает ли какая-либо строка 
с шаблоном шестнадцатеричного кода.

## Проверка адреса электронной почты

    /[A-Z0-9._%+-]+@[A-Z0-9-]+.+.[A-Z]{2,4}/igm 

Одной из самых распространенных задач при разработке является проверка соответствия 
введенной пользователем строки формату адреса электронной почты. Существует множество 
различных вариантов выражений для решения этой задачи, автор этой статьи предлагает 
свой оригинальный вариант.

## IP-адрес

v4:

    /\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b/ 

    ((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)

v6:

    ((^|:)([0-9a-fA-F]{0,4})){1,8}$

Как e-mail может использоваться для идентификации посетителя, так IP-адрес является идентификатором 
конкретного компьютера в сети. Приведенное регулярное выражение проверяет соответствие строки 
формату IP-адреса v4.

## IP-адрес (v6)

    (([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])) 

Вы также можете проверить строку на соответствие формату IP-адреса новой, 
шестой версии более продвинутым регулярным выражением.

## Разделитель в больших числах

    /\d{1,3}(?=(\d{3})+(?!\d))/g 

Традиционными разделителями в больших числах являются запятые, точки или другие знаки, 
повторяющиеся в числе через каждые 3 символа. Приведенный код регулярного выражения работает 
с любым числом и любым определенными вами символами для разделения трехзначных частей 
в больших числах: тысячах, миллионах и т.п.

## Добавление протокола перед гиперссылкой

    if (!s.match(/^[a-zA-Z]+:\/\//))
    {
        s = 'http://' + s;
    }

Независимо от того, с каким языком вы работаете: JavaScript, Ruby или PHP, 
это регулярное выражение может оказаться очень полезным. С его помощью проверяется любой 
URL-адрес на наличие в строке протокола, и если протокол отсутствует, указанный код 
добавляет его в начало строки.

## «Вытягиваем» домен из URL-адреса.

    /https?:\/\/(?:[-\w]+\.)?([-\w]+)\.\w+(?:\.\w+)?\/?.*/i 

Как известно, любой URL-адрес состоит из нескольких частей: вначале указывается протокол (HTTP или HTTPS), 
иногда за ним идет субдомен, а в завершении добавляется путь к странице. 
Вы можете использовать это выражение, чтобы вернуть только доменное имя, 
исключив все остальные части адреса.

## Сортировка ключевых фраз по количеству слов

    ^[^\s]*$        //соответствует одному ключевому слову
    ^[^\s]*\s[^\s]*$    //соответствует фразе из 2 ключевых слов
    ^[^\s]*\s[^\s]*     //соответствует фразе, содержащей по крайней мере 2 кючевых слова
    ^([^\s]*\s){2}[^\s]*$    //соответствует фразе из 3 ключевых слов
    ^([^\s]*\s){4}[^\s]*$    //соответствует фразе из 5 и более ключевых слов

Это действительно полезные выражения для пользователей Google Analytics и инструмента для веб-мастеров. 
Ведь с помощью них можно отсортировать ключевые фразы, используемые посетителями при поиске 
по количеству слов, входящих в них.

Выражения могут проверять фразы, содержащие определенное количество слов (например, 5), 
а также фразы количество слов в которых более двух, трех и т.д. Одно из самых мощных выражений, 
используемое для сортировки данных аналитики.

## Поиск валидной строки Base64 в PHP

    \?php[ \t]eval\(base64_decode\(\'(([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)?){1}\'\)\)\; 

Если вы являетесь PHP-разработчиком, то иногда вам может понадобиться найти объект, 
закодированный в формате Base64. Указанное выше выражение может использоваться 
для поиска закодированных строк в любом PHP-коде.

## Проверка телефонного номера

    ^\+?\d{1,3}?[- .]?\(?(?:\d{2,3})\)?[- .]?\d\d\d[- .]?\d\d\d\d$ 

Это регулярное выражение применяется для проверки любого номера телефона, прежде всего, 
американского формата телефонных номеров.

Проверка телефонных номеров может стать довольно сложной задачей, поэтому автор статьи рекомендует 
детально ознакомиться с различными вариантами решения на сайте [stackoverflow.com](http://stackoverflow.com/questions/123559/a-comprehensive-regex-for-phone-number-validation)

Для проверки российских телефонных номеров используйте следующее выражение:

    ^((\+?7|8)[ \-] ?)?((\(\d{3}\))|(\d{3}))?([ \-])?(\d{3}[\- ]?\d{2}[\- ]?\d{2})$

## Начальные и конечные пробелы

    ^[ \s]+|[ \s]+$ 

Используйте это регулярное выражение для того, чтобы избавиться от начальных и 
конечных пробелом в строке. Это не особо распространенная задача, но иногда это выражение 
может быть полезным. Например, при получении данных из БД или передачи строки скрипту в другой кодировке.

## «Вытягиваем» HTML-код изображения

    \< *[img][^\>]*[src] *= *[\"\']{0,1}([^\"\'\ >]*) 

Если по какой-либо причине вам необходимо «вытянуть» HTML-код изображения прямо из кода страницы, 
это регулярное выражение станет для вас идеальным решением. Хотя оно может без проблем работать 
на стороне сервера, для фронтенд-разработчиков приоритетней будет использовать метод `attr()` 
библиотеки jQuery вместо указанного регулярного выражения.

## Проверяем дату на соответствие формату

DD/MM/YYYY:

    ^(?:(?:31(\/|-|\.)(?:0?[13578]|1[02]))\1|(?:(?:29|30)(\/|-|\.)(?:0?[1,3-9]|1[0-2])\2))(?:(?:1[6-9]|[2-9]\d)?\d{2})$|^(?:29(\/|-|\.)0?2\3(?:(?:(?:1[6-9]|[2-9]\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))$|^(?:0?[1-9]|1\d|2[0-8])(\/|-|\.)(?:(?:0?[1-9])|(?:1[0-2]))\4(?:(?:1[6-9]|[2-9]\d)?\d{2})$ 

    (0[1-9]|[12][0-9]|3[01])[- /.](0[1-9]|1[012])[- /.](19|20)\d\d

YYYY-MM-DD:

    [0-9]{4}-(0[1-9]|1[012])-(0[1-9]|1[0-9]|2[0-9]|3[01])


YYYY-MM-DD (строгая проверка):

    (19|20)\d\d-((0[1-9]|1[012])-(0[1-9]|[12]\d)|(0[13-9]|1[012])-30|(0[13578]|1[02])-31)

Проверять даты сложно, потому что они могут быть представлены в различных форматах, 
в том числе содержащих и числа, и текст.

В PHP имеется отличная функция date(), но она не всегда подходит, ведь в нее может быть передана 
необработанная строка. Поэтому для проверки указанного формата даты нужно использовать приведенное 
выше регулярное выражение.

## Совпадение строки с адресом видеоролика на YouTube

    /http:\/\/(?:youtu\.be\/|(?:[a-z]{2,3}\.)?youtube\.com\/watch(?:\?|#\!)v=)([\w-]{11}).*/gi 

На протяжении нескольких лет на Youtube не меняется структура URL-адресов. 
Youtube является самым популярным видео хостингом в Интернет, благодаря этому, видео с Youtube 
набирают наибольший трафик.

Если вам необходимо получить ID какого-либо видеоролика с Youtube, воспользуйтесь приведенным 
выше регулярным выражением. Это наилучшее выражение, подходящее для всех вариантов URL-адресов 
на этом видео-хостинге.

## Проверка ISBN

    /\b(?:ISBN(?:: ?| ))?((?:97[89])?\d{9}[\dx])\b/i 

Информация обо всех печатные изданиях, хранится в системе, известной как ISBN, которая состоит 
из 2 систем: ISBN-10 и ISBN-13. Неспециалисту очень сложно увидеть различия между этими системами. 
Однако, представленное выше регулярное выражение позволяет проверять соответствие кода ISBN сразу 
обоим системам: будь то ISBN-10 или ISBN-13. Код написан на PHP, поэтому это решение подходит 
исключительно для веб-разработчиков.

## Проверка почтового индекса (Zip Code)

    ^\d{5}(?:[-\s]\d{4})?$ 

Автор этого регулярного выражения не только придумал его, но и еще нашел время его описать. 
Это выражение будет полезно вам, если вы проверяете совпадение строки со стандартным 
пятизначным индексом или его удлиненным вариантом, содержащим 9 знаков. Обращаем ваше внимание, 
что это выражение подходит только для проверки американских почтовых индексов. 
Для индексов других стран необходима настройка.

Для проверки российских почтовых индексов используйте следующее выражение:

    ^\d{6}$ 

## Проверка правильности имени пользователя Twitter

    /@([A-Za-z0-9_]{1,15})/ 

Это небольшое регулярное выражение помогает найти имя пользователя Twitter внутри текста. 
Оно проверяет наличие имени в твитах по шаблону: @username.

## Проверка номера кредитной карты

    ^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})$  

Проверка номера кредитной карты очень часто проводится при осуществлении платежей в различных платежных 
онлайн-системах. Однако, регулярное выражение обеспечивает минимальную проверку стандартной кредитной карты.

Вы можете ознакомиться с более полным списком кодов для детальной проверки карт. 
Список включает в себя такие системы как Visa, MasterCard, Discover и многие другие.

## Поиск CSS-атрибутов

    ^\s*[a-zA-Z\-]+\s*[:]{1}\s[a-zA-Z0-9\s.#]+[;]{1} 

Ситуация, когда придется воспользоваться указанным регулярным выражением, может сложиться очень редко, 
но не факт что не сложится никогда

Этот код можно использовать когда будет необходимо «вытянуть» какое-либо CSS-правило из списка 
правил для какого-нибудь селектора.

## Удаление комментариев в HTML

    <!--(.*?)--> 

Если вам необходимо удалить все комментарии из блока HTML-кода, воспользуйтесь этим регулярным 
выражением. Чтобы получить желаемый результат, вы можете воспользоваться PHP-функцией `preg_replace()`.

## Проверка на соответствие ссылке на Facebook-аккаунт

    /(?:http:\/\/)?(?:www\.)?facebook\.com\/(?:(?:\w)*#!\/)?(?:pages\/)?(?:[\w\-]*\/)*([\w\-]*)/ 

Если вам необходимо узнать у посетителя вашего сайта адрес его странички в Facebook, попробуйте это 
регулярное выражение. Оно поможет вам проверить правильность указанного пользователем URL. 
Этот код отлично подходит для проверки ссылок в этой соцсети.

## Проверка версии Internet Explorer

    ^.*MSIE [5-8](?:\.[0-9]+)?(?!.*Trident\/[5-9]\.0).*$ 

Несмотря на то, что Microsoft выпустил новый браузер Edge, многие пользователи до сих пор пользуются Internet Explorer. 
Веб-разработчикам часто приходится проверять версию этого браузера, чтобы учитывать особенности разных версий 
при работе над своими проектами.

Вы можете использовать это регулярное выражения в JavaScript-коде чтобы узнать какая версия 
IE (5-11) используется.

## «Вытягиваем» цену из строки

    /(\$[0-9,]+(\.[0-9]{2})?)/ 

Цена какого-либо товара может быть указана в различных форматах: в ней могут встречаться запятые, 
знаки после запятой и символы валюты.

Указанное выше регулярное выражение учитывает различные форматы отображения цены, 
с его помощью вы сможете «вытянуть» цену из любой символьной строки.

## Разбираем заголовки в e-mail

    /\b[A-Z0-9._%+-]+@(?:[A-Z0-9-]+\.)+[A-Z]{2,6}\b/i

С помощью этого небольшого выражения вы сможете разобрать заголовок e-mail сообщения, 
чтобы извлечь оттуда список адресатов. Выражение может быть использовано и в случае, 
если адресатов несколько.

Вместо регулярных выражений, для разбора заголовков e-mail вы можете воспользуйтесь библиотекой на PHP.

## Соответствие имени файла определенному типу

    /^(.*\.(?!(htm|html|class|js)$))?[^.]*$/i 

Если в вашем приложении существует возможность загрузки файлов на сервер, это регулярное выражение 
может помочь вам проверить файлы перед тем как посетитель их загрузит.

С помощью этого кода можно получить расширение загружаемого файла и проверить присутствует ли оно 
в списке разрешенных к загрузке.

## Соответствие строки формату URL

    /[-a-zA-Z0-9@:%_\+.~#?&//=]{2,256}\.[a-z]{2,4}\b(\/[-a-zA-Z0-9@:%_\+.~#?&//=]*)?/gi 

Регулярное выражение может проверять URL-адреса с указанием протоколов HTTP и HTTPS на предмет 
соответствия синтаксису доменов TLD.

Существует простой способ проверки с использованием JavaScript RegExp.

## Добавление атрибута rel=”nofollow” в теге ссылки

    (<a\s*(?!.*\brel=)[^>]*)(href="/https?://)((?!(?:(?:www\.)?'.implode('|(?:www\.)?', $follow_list).'))[^"]+)"((?!.*\brel=)[^>]*)(?:[^>]*)> 

Если вы много работаете с HTML-кодом, то вам захочется автоматизировать часто повторяющиеся действия. 
Регулярные выражения отлично подходят для решения этой задачи и сэкономят много вашего времени.

Используя приведенный код, например, совместно с PHP, вы сможете «вытянуть» код ссылок из блоков 
HTML-кода и добавить в каждую из них атрибут rel=”nofollow”.

## Работа с media query

    /@media([^{]+)\{([\s\S]+?})\s*}/g 

Вы можете разбивать строки содержащие медиа-запросы на части, состоящие из параметров и свойств. 
Указанное выражение может быть полезно для анализа стороннего CSS-кода. Используя его вы сможете, 
например, более подробно понять как устроен чужой код.

## Синтаксис поисковых выражений Google

    /([+-]?(?:'.+?'|".+?"|[^+\- ]{1}[^ ]*))/g 

Вы можете составить свои собственные регулярные выражения для манипулирования результатами поиска 
по вашим запросам в поисковой системе Google. Например, знак плюс (+) добавляет дополнительные 
ключевые слова, а минус (-) означает, что слова должны быть проигнорированы и удалены из результатов.

Это довольно сложное выражение, но если разобраться как использовать его должным образом, 
приведенный код может стать основой для построения собственного алгоритма поиска.

## Последовательности из 5 цифр

    \d{5}

`\d` означает любую цифру
`{5}` — ровно 5 раз

## Даты в формате ДД/ММ/ГГГГ

    \d\d/\d\d/\d{4}

(и прочие куски, на них похожие, например, `98/76/5432`)

## Слова в точности из трёх букв

    \b\w{3}\b

* `\b` означает границу слова (с одной стороны буква, а с другой — нет)
* `\w` — любая буква,
* `{3}` — ровно три раза

## Целое число

    [-+]?\d+

например, `7`, `+17`, `-42`, `0013` (возможны ведущие нули)

* `[-+]?` — либо -, либо +, либо пусто
* `\d+` — последовательность из 1 или более цифр

## Действительное число, возможно в экспоненциальной записи

    [-+]?(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][-+]?\d+)?

Например, `0.2`, `+5.45`, `-.4`, `6e23`, `-3.17E-14`.

## UUID

    [0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}

## URL

    (?:(?:https?|ftp|telnet)://(?:[a-z0-9_-]{1,32}(?::[a-z0-9_-]{1,32})?@)?)?(?:(?:[a-z0-9-]{1,128}\.)+(?:ru|su|com|net|org|mil|edu|arpa|gov|biz|info|aero|inc|name|[a-z]{2})|(?!0)(?:(?!0[^.]|255)[0-9]{1,3}\.){3}(?!0|255)[0-9]{1,3})(?:/[a-z0-9.,_@%&?+=\~/-]*)?(?:#[^ '\"&]*)?

URL с кирилицей:

    (?:(?:https?|ftp|telnet)://(?:[а-яёa-z0-9_-]{1,32}(?::[а-яёa-z0-9_-]{1,32})?@)?)?(?:(?:[а-яёa-z0-9-]{1,128}\.)+(?:ru|su|com|net|org|mil|edu|arpa|gov|biz|info|aero|inc|name|[a-z]{2})|(?!0)(?:(?!0[^.]|255)[0-9]{1,3}\.){3}(?!0|255)[0-9]{1,3})(?:/[а-яёa-z0-9.,_@%&?+=\~/-]*)?(?:#[^ '\"&]*)?

## MAC-адрес

    ([0-9a-fA-F]{2}([:-]|$)){6}$|([0-9a-fA-F]{4}([.]|$)){3}

## Наборы символов

латиница и кирилица:

    [а-яА-ЯёЁa-zA-Z]
    
латиница:

    [a-zA-Z]

кирилица:

    [а-яА-ЯёЁ]

Набор из латиницы и цифр:

    [a-zA-Z0-9]

Набор из латиницы, кирилицы и цифр:

    [а-яА-ЯёЁa-zA-Z0-9]

## Имя пользователя

с ограничением 2-20 символов, которыми могут быть буквы и цифры, первый символ обязательно буква

    ^[a-zA-Z][a-zA-Z0-9-_\.]{1,20}$

латиница, цифры, знаки `_` и `-`, минимально 3 символа, максимально - 16

    [a-z0-9_-]{3,16}

## Документация и инструменты

* [Оригинальная документация](https://docs.python.org/3/library/re.html)
* [Очень подробный и обстоятельный материал](https://www.regular-expressions.info/)
* [Разные сложные трюки и тонкости с примерами](http://www.rexegg.com/)
* [Он-лайн отладка регулярок](https://regex101.com) (не забудьте поставить галочку Python в разделе FLAVOR слева)
* [Он-лайн визуализация регулярок](https://www.debuggex.com/)  (не забудьте выбрать Python)
* Могущественный текстовый редактор Sublime text 3, в котором очень удобный поиск по регуляркам

## Ссылки

* [Ссылка на источник 1](https://mattweb.ru/moj-blog/raznoe/item/142-30-primero)
* [Ссылка на источник 2](https://habr.com/ru/post/349860/)
